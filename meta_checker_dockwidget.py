# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MetaCheckerDockWidget
                                 A QGIS plugin
 Check layer metadata befor loading it
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2020-07-07
        git sha              : $Format:%H$
        copyright            : (C) 2020 by Michał Król
        email                : demix.97@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os, datetime, ntpath, csv

from qgis.PyQt import QtGui, uic
from qgis.PyQt.QtCore import pyqtSignal
from qgis.PyQt.QtWidgets import QDockWidget, QFileDialog
from qgis.core import QgsVectorLayer, QgsProject

from .meta_table_model import MetaTableModel

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'meta_checker_dockwidget_base.ui'))


class MetaCheckerDockWidget(QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self, parent=None):
        """Constructor."""
        super(MetaCheckerDockWidget, self).__init__(parent)
        self.setupUi(self)

        # Podpięcie modelu pod table view (wzorzec MVC)
        self.tvFilesMeta.setModel(MetaTableModel())
        # Podpięcie sygnałów pod przyciski
        self.tbLoad.clicked.connect(self.loadFiles)
        self.tbExport.clicked.connect(self.exportCsv)
        self.tbRemove.clicked.connect(self.removeRows)
        self.tbClear.clicked.connect(lambda: self.removeRows(all_=True))
        self.tbLoadQgis.clicked.connect(self.loadLayers)

    def closeEvent(self, event):
        self.closingPlugin.emit()
        event.accept()

    def loadFiles(self):
        """ Wczytywanie metadanych plików do tabeli """
        # Okno do wyboru plików
        files, filters = QFileDialog.getOpenFileNames(self, 'Open file', filter='ESRI Shapefile (*.shp)')
        # Brak wybranych plików - zakończenie funkcji (inaczej crash qgis)
        if not files:
            return
        # Iteracja po wybranych plikach i zebranie informacji do słownika
        files_meta = []
        for file_ in files:
            file_name = ntpath.basename(file_)
            stat = os.stat(file_)
            layer = QgsVectorLayer(file_, file_name, 'ogr')
            files_meta.append({
                'name': file_name,
                'size': str(stat.st_size)+'B',
                'obj_count': str(layer.featureCount()),
                'column_count': str(len(layer.attributeList())),
                'colum_names': ', '.join(layer.fields().names()),
                'epsg': layer.sourceCrs().authid(),
                'modified': datetime.datetime.fromtimestamp(stat.st_mtime).isoformat(),
                'abs_path': file_
            })
        # Dodanie metadanych wybranych plików jako wiersze tabeli
        self.tvFilesMeta.model().insertRows(0, files_meta)
        
    def exportCsv(self):
        """ Eksport tabeli do CSV """
        # Zebranie metadanych z tabeli
        meta = self.tvFilesMeta.model().files_meta
        # Wybór ścieżki do zapisania pliku csv
        path, _ = QFileDialog.getSaveFileName(filter='*.csv')
        # Brak ścieżki - zakończenie metody
        if not path:
            return
        # Ochrona przed dublowaniem rozszerzenia
        if not path.lower().endswith('.csv'):
            path += '.csv'
        # Zapisanie pliku csv w wybranym miejscu
        with open(path, 'w') as f:
            writer = csv.writer(f)
            # Nagłówki
            writer.writerow(['Nazwa', 'Rozmiar', 'Liczba obiektów', 'Liczba kolumn', 'Nazwy kolumn', 'Układ współrzędnych', 'Data modyfikacji', 'Pełna ścieżka'])
            # Iteracja po metadanych pliku i zapis 
            for m in meta:
                writer.writerow(m.values())

    def loadLayers(self):
        """ Wczytanie zaznacoznych warstw w tabeli do TOC (Table of Contents) """
        rows = []
        # Iteracja po zaznaczonych wierszach w tabeli
        for index in self.tvFilesMeta.selectedIndexes():
            # Zabezpieczenie przed multiplikacją wczytanych warstw
            if index.row() not in rows:
                rows.append(index.row())
                # Wybór odpowiedniego elemntu z listy metadanych z modelu
                meta = self.tvFilesMeta.model().files_meta[index.row()]
                # Zapisanie niezbędnych danych do wczytania warstwy
                path = meta['abs_path']
                name = meta['name']
                # Stworzenie warstwy 
                layer = QgsVectorLayer(path, name, 'ogr')
                # Wczytanie warstwy do QGIS TOC
                QgsProject.instance().addMapLayer(layer)

    def removeRows(self, all_=False):
        """ Usuwanie wszystkich lub wybranych wierszy z tabeli """
        # Jeśli przycisk "Wyczyść", wszystkie wiersze są usuwane
        if all_:
            self.tvFilesMeta.model().removeRows()
            return
        # Usunięcie wybranych wierszy
        rows = []
        # Iteracja po zaznaczonych wierszach
        for index in self.tvFilesMeta.selectedIndexes():
            # Zabezpieczenie przed multiplikacją 
            if index.row() not in rows:
                rows.append(index.row())
                # Wywołanie odpowiedniej metody z modelu do usuwania wierszy
                self.tvFilesMeta.model().removeRows(index.row(), 1)
